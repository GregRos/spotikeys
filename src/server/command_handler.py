from logging import getLogger
from os import PathLike
from pathlib import Path
from threading import Event
import time
from typing import override

from src.now_playing import MediaStatus
from src.commanding import Command
from src.commanding.handler import PropertyBasedCommandHandler
from src.server.history import PersistentCommandHistory

from src.commands import *
from src.server.spotify import Root, playback


logger = getLogger("server")


class NoPlaybackError(Exception):
    def __init__(self):
        super().__init__("Nothing is playing right now.")


class MediaCommandHandler(MediaCommands, PropertyBasedCommandHandler):
    root: Root
    cancel_flag = Event()
    _last_volume = 0

    def __init__(self, root: Root, history_file: PathLike):
        super().__init__("media")
        self.root = root
        self.history = PersistentCommandHistory(history_file, commands)

    def exec(self, command: Command):
        self.history.push(command)

    def pop_cancel(self):
        is_set = self.cancel_flag.is_set()
        self.cancel_flag.clear()
        return is_set

    @property
    def expect_playback(self):
        match self.root.playback:
            case None:
                raise NoPlaybackError()
            case playback:
                return playback

    @override
    def seek_fwd(self):
        self.expect_playback.progress += 30

    @override
    def seek_bwd(self):
        self.expect_playback.progress -= 30

    @override
    def play_pause(self):
        playback = self.expect_playback
        if playback.is_playing:
            playback.pause()
            self.history.push(MediaCommands.play)
        else:
            playback.play()
            self.history.push(MediaCommands.pause)

    @override
    def volume_up(self):
        old_volume = self.expect_playback.volume
        self.expect_playback.volume = min(100, old_volume + 20)
        self.history.push(MediaCommands.volume_to(old_volume))

    @override
    def volume_down(self):
        old_volume = self.expect_playback.volume
        self.expect_playback.volume = max(0, old_volume - 20)
        self.history.push(MediaCommands.volume_to(old_volume))

    @override
    def volume_mute(self):
        playback = self.expect_playback
        cur_volume = playback.volume
        if cur_volume == 0:
            playback.volume = self._last_volume
        else:
            self._last_volume = self.expect_playback.volume
            playback.volume = 0
        self.history.push(MediaCommands.volume_to(cur_volume))

    @override
    def volume_max(self):
        old_volume = self.expect_playback.volume
        self.expect_playback.volume = 100
        self.history.push(MediaCommands.volume_to(old_volume))

    @override
    def cancel(self):
        print("Cancel")

    @override
    def unlove(self, track_id: str):
        track = self.root.track(track_id)
        track.unsave()
        if album := track.album:
            album.unsave()
        for artist in track.artists:
            artist.unsave()

    @override
    def love(self):
        track = self.expect_playback.track
        track.save()
        if album := track.album:
            album.save()
        for artist in track.artists:
            artist.save()
        self.history.push(MediaCommands.unlove(track.id))

    @override
    def prev_track(self):
        self.expect_playback.prev_track()
        self.history.push(MediaCommands.next_track)

    @override
    def next_track(self):
        self.expect_playback.next_track()
        self.history.push(MediaCommands.prev_track)

    @override
    def loop_track(self):
        playback = self.expect_playback
        old_repeat = playback.repeat
        playback.repeat = "track"
        self.history.push(MediaCommands.repeat_to(old_repeat))

    @override
    def undo(self):
        print("Undo")

    @override
    def redo(self):
        print("Redo")

    @override
    def spin_this_in_last(self):
        playback = self.expect_playback
        track = playback.track
        recommended = track.recommend()
        playlists = self.root.current_user.playlists
        autogenerated = [pl for pl in playlists if pl.name.startswith("ðŸ¤–")][0]
        logger.info(f"Found {autogenerated.name}")
        autogenerated.name = f"ðŸ¤– {track.artists_string} â€“ {track.name}"
        old_track_ids = [t.id for t in autogenerated.tracks]
        autogenerated.clear()
        logger.info(f"Cleared {autogenerated.name}")
        autogenerated.add(*recommended)
        logger.info(f"Added {len(recommended)} tracks to {autogenerated.name}")
        self.history.push(
            MediaCommands.set_playlist_tracks(
                {"id": autogenerated.id, "tracks": old_track_ids}
            )
        )
        autogenerated.play()

    @override
    def spin_this_in_new(self):
        track = self.expect_playback.track
        recommended = track.recommend()
        logger.info(f"Got {len(recommended)} tracks for {track.name}")
        new_playlist = self.root.current_user.playlists.add(
            f"ðŸ¤– {track.artists_string} â€“ {track.name}", description="Auto-generated."
        )
        logger.info(f"Created playlist {new_playlist.name}")
        new_playlist.add(*recommended)
        logger.info(f"Added {len(recommended)} tracks to {new_playlist.name}")
        self.history.push(MediaCommands.delete_playlist(new_playlist.id))
        new_playlist.play()

    @override
    def get_status(self):
        pass

    @override
    def rewind_this(self):
        playback = self.expect_playback
        old_repeat = playback.repeat
        playback.repeat = "off"
        try:
            while playback.allows("skipping_prev"):
                playback.prev_track()
        finally:
            playback.repeat = old_repeat

    @override
    def next_multi(self):
        print("Next multi")

    @override
    def prev_multi(self):
        print("Prev multi")

    @override
    def show_status(self):
        raise NotImplementedError("Local command only.")

    @override
    def hide_status(self):
        raise NotImplementedError("Local command only.")

    def get_media(self):
        if playback := self.root.playback:
            return MediaStatus(
                title=playback.track.name,
                artist=playback.track.artists[0].name,
                album=playback.track.album.name,
                duration=playback.track.duration,
                position=playback.progress,
                is_playing=playback.is_playing,
            )

    @override
    def __call__(self, command: Command):
        logger.info(f"Received command: {command}")
        start = time.time()
        result = super().__call__(command) or self.get_media()
        elapsed = time.time() - start
        logger.info(f"Command {command} took {elapsed:.3f} seconds")
        return result
